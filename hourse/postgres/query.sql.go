// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: query.sql

package postgres

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const getCities = `-- name: GetCities :many
SELECT name FROM city
`

func (q *Queries) GetCities(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHourses = `-- name: GetHourses :many
WITH duplicate_conditions AS (
    SELECT MIN(id) AS id, section_id, address, age, area
    FROM hourse
    WHERE link LIKE 'https://sale.591.com.tw/home%'
    AND updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
    GROUP BY section_id, address, age, area
    HAVING count(1) > 1
),
duplicate AS (
    SELECT hourse.id
    FROM hourse
    INNER JOIN duplicate_conditions ON(
            hourse.section_id = duplicate_conditions.section_id
        AND hourse.address = duplicate_conditions.address
        AND hourse.age = duplicate_conditions.age
        AND hourse.area = duplicate_conditions.area
        AND hourse.link LIKE 'https://sale.591.com.tw/home%'
    )
    WHERE hourse.id NOT IN (SELECT id FROM duplicate_conditions)
    AND hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
),
candidates AS (
    SELECT hourse.id
    FROM hourse
    LEFT JOIN section ON (section.id=hourse.section_id)
    LEFT JOIN city ON (city.id=section.city_id)
    WHERE hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '7 day'
    AND hourse.id NOT IN (SELECT id FROM duplicate)
    AND hourse.main_area IS NOT NULL
    AND (city.name IN ($1) OR COALESCE($1, '') = '')
    AND (section.name IN ($2) OR COALESCE($2, '') = '')
    AND ($3 = 0 OR hourse.price < $3)
    AND (hourse.age < $4 OR COALESCE($4, '') = '')
    AND ($5 = 0 OR hourse.main_area > $5 :: DECIMAL)
    AND (hourse.shape IN ($6) OR COALESCE($6, '') = '')
    AND (
        CASE
        WHEN hourse.shape = '公寓' THEN hourse.current_floor = '3F'
        ELSE TRUE
        END
    )
    AND hourse.current_floor != hourse.total_floor
    AND hourse.current_floor NOT IN ('-1F', 'B1F', 'B1', '頂樓加蓋')
)
SELECT
    hourse.id,
    CONCAT(city.name, section.name, hourse.address) :: TEXT AS address,
    city.name AS city,
    section.name AS section,
    hourse.price,
    hourse.current_floor,
    CONCAT(hourse.current_floor, '/', hourse.total_floor) :: TEXT AS floor,
    hourse.shape,
    hourse.age,
    hourse.main_area,
    hourse.area,
    hourse.layout,
    section.name AS section,
    hourse.link,
    COALESCE(hourse.commit, '') AS commit,
    hourse.created_at,
    (SELECT COUNT(1) FROM candidates) AS total_count
FROM hourse
INNER JOIN candidates USING(id)
LEFT JOIN section ON (section.id=hourse.section_id)
LEFT JOIN city ON (city.id=section.city_id)
ORDER BY hourse.age, hourse.price, hourse.main_area
`

type GetHoursesParams struct {
	City        string
	Section     string
	MaxPrice    interface{}
	Age         string
	MinMainArea interface{}
	Shape       string
}

type GetHoursesRow struct {
	ID           int64
	Address      string
	City         sql.NullString
	Section      sql.NullString
	Price        string
	CurrentFloor string
	Floor        string
	Shape        string
	Age          string
	MainArea     sql.NullString
	Area         string
	Layout       sql.NullString
	Section_2    sql.NullString
	Link         string
	Commit       string
	CreatedAt    time.Time
	TotalCount   int64
}

func (q *Queries) GetHourses(ctx context.Context, arg GetHoursesParams) ([]GetHoursesRow, error) {
	rows, err := q.db.QueryContext(ctx, getHourses,
		arg.City,
		arg.Section,
		arg.MaxPrice,
		arg.Age,
		arg.MinMainArea,
		arg.Shape,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHoursesRow
	for rows.Next() {
		var i GetHoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.City,
			&i.Section,
			&i.Price,
			&i.CurrentFloor,
			&i.Floor,
			&i.Shape,
			&i.Age,
			&i.MainArea,
			&i.Area,
			&i.Layout,
			&i.Section_2,
			&i.Link,
			&i.Commit,
			&i.CreatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSection = `-- name: GetSection :one
SELECT section.id, city_id, section.name, section.created_at, section.deleted_at, city.id, city.name, city.created_at, city.deleted_at
FROM section
LEFT JOIN city ON (section.city_id = city.id)
WHERE city.name = $1
AND section.name = $2
`

type GetSectionParams struct {
	City    string
	Section string
}

type GetSectionRow struct {
	ID          int64
	CityID      int32
	Name        string
	CreatedAt   time.Time
	DeletedAt   sql.NullTime
	ID_2        sql.NullInt64
	Name_2      sql.NullString
	CreatedAt_2 sql.NullTime
	DeletedAt_2 sql.NullTime
}

func (q *Queries) GetSection(ctx context.Context, arg GetSectionParams) (GetSectionRow, error) {
	row := q.db.QueryRowContext(ctx, getSection, arg.City, arg.Section)
	var i GetSectionRow
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.Name,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.ID_2,
		&i.Name_2,
		&i.CreatedAt_2,
		&i.DeletedAt_2,
	)
	return i, err
}

const getSectionsByCity = `-- name: GetSectionsByCity :many
SELECT section.name
FROM section
LEFT JOIN city ON (section.city_id = city.id)
WHERE city.name = $1
`

func (q *Queries) GetSectionsByCity(ctx context.Context, cityName string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsByCity, cityName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsWithCity = `-- name: GetSectionsWithCity :many
SELECT section.name AS section, city.name AS city
FROM section
LEFT JOIN city ON (section.city_id = city.id)
`

type GetSectionsWithCityRow struct {
	Section string
	City    sql.NullString
}

func (q *Queries) GetSectionsWithCity(ctx context.Context) ([]GetSectionsWithCityRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsWithCity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectionsWithCityRow
	for rows.Next() {
		var i GetSectionsWithCityRow
		if err := rows.Scan(&i.Section, &i.City); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertHourse = `-- name: UpsertHourse :exec

INSERT INTO hourse (
    section_id, link, layout, address, price, current_floor, total_floor,
    shape, age, area, main_area, raw)
VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11, $12)
ON CONFLICT (link)
DO UPDATE
SET updated_at = CURRENT_TIMESTAMP, price = EXCLUDED.price
`

type UpsertHourseParams struct {
	SectionID    int32
	Link         string
	Layout       sql.NullString
	Address      sql.NullString
	Price        string
	CurrentFloor string
	TotalFloor   string
	Shape        string
	Age          string
	Area         string
	MainArea     sql.NullString
	Raw          json.RawMessage
}

// OFFSET @offset_param :: INTEGER LIMIT @limit_param :: INTEGER;
func (q *Queries) UpsertHourse(ctx context.Context, arg UpsertHourseParams) error {
	_, err := q.db.ExecContext(ctx, upsertHourse,
		arg.SectionID,
		arg.Link,
		arg.Layout,
		arg.Address,
		arg.Price,
		arg.CurrentFloor,
		arg.TotalFloor,
		arg.Shape,
		arg.Age,
		arg.Area,
		arg.MainArea,
		arg.Raw,
	)
	return err
}
