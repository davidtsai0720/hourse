// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: query.sql

package postgres

import (
	"context"
	"database/sql"
	"time"
)

const getCities = `-- name: GetCities :many
SELECT name FROM city
`

func (q *Queries) GetCities(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHourse = `-- name: GetHourse :many
WITH duplicate_conditions AS (
    SELECT MIN(id) AS id, section_id, address, age, area
    FROM hourse
    WHERE link LIKE 'https://sale.591.com.tw/home%'
    AND updated_at > CURRENT_TIMESTAMP - INTERVAL '1 day'
    GROUP BY section_id, address, age, area
    HAVING count(1) > 1
),
duplicate AS (
    SELECT hourse.id
    FROM hourse
    INNER JOIN duplicate_conditions ON(
            hourse.section_id = duplicate_conditions.section_id
        AND hourse.address = duplicate_conditions.address
        AND hourse.age = duplicate_conditions.age
        AND hourse.area = duplicate_conditions.area
        AND hourse.link LIKE 'https://sale.591.com.tw/home%'
    )
    WHERE hourse.id NOT IN (SELECT id FROM duplicate_conditions)
    AND hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '1 day'
),
candidates AS (
    SELECT hourse.id
    FROM hourse
    LEFT JOIN section ON (section.id=hourse.section_id)
    LEFT JOIN city ON (city.id=section.city_id)
    WHERE hourse.updated_at > CURRENT_TIMESTAMP - INTERVAL '1 day'
    AND hourse.id NOT IN (SELECT id FROM duplicate)
    AND hourse.main_area IS NOT NULL
    AND (city.name IN ($3) OR COALESCE($3, '') = '')
    AND (section.name IN ($4) OR COALESCE($4, '') = '')
    AND ($5 = 0 OR hourse.price < $5)
    AND ($6 = 0 OR hourse.main_area > $6 :: DECIMAL)
    AND (hourse.shape IN ($7) OR COALESCE($7, '') = '')
    AND (
        CASE
        WHEN $8 :: BOOLEAN THEN hourse.current_floor != hourse.total_floor
        ELSE TRUE
        END
    )
)
SELECT
    hourse.id,
    CONCAT(city.name, section.name, hourse.address) :: TEXT AS address,
    city.name AS city,
    section.name AS section,
    hourse.price,
    hourse.current_floor,
    CONCAT(hourse.current_floor, '/', hourse.total_floor) :: TEXT AS floor,
    hourse.shape,
    hourse.age,
    hourse.main_area,
    hourse.area,
    section.name AS section,
    hourse.link,
    COALESCE(hourse.commit, '') AS commit,
    hourse.created_at,
    (SELECT COUNT(1) FROM candidates) AS total_count
FROM hourse
INNER JOIN candidates USING(id)
LEFT JOIN section ON (section.id=hourse.section_id)
LEFT JOIN city ON (city.id=section.city_id)
ORDER BY city.name, section.name, hourse.age, hourse.price, hourse.address
OFFSET $1 :: INTEGER LIMIT $2 :: INTEGER
`

type GetHourseParams struct {
	OffsetParam      int32
	LimitParam       int32
	City             string
	Section          string
	MaxPrice         interface{}
	MinMainArea      interface{}
	Shape            string
	ExcludedTopFloor bool
}

type GetHourseRow struct {
	ID           int64
	Address      string
	City         sql.NullString
	Section      sql.NullString
	Price        int32
	CurrentFloor string
	Floor        string
	Shape        string
	Age          string
	MainArea     sql.NullString
	Area         string
	Section_2    sql.NullString
	Link         string
	Commit       string
	CreatedAt    time.Time
	TotalCount   int64
}

func (q *Queries) GetHourse(ctx context.Context, arg GetHourseParams) ([]GetHourseRow, error) {
	rows, err := q.db.QueryContext(ctx, getHourse,
		arg.OffsetParam,
		arg.LimitParam,
		arg.City,
		arg.Section,
		arg.MaxPrice,
		arg.MinMainArea,
		arg.Shape,
		arg.ExcludedTopFloor,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHourseRow
	for rows.Next() {
		var i GetHourseRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.City,
			&i.Section,
			&i.Price,
			&i.CurrentFloor,
			&i.Floor,
			&i.Shape,
			&i.Age,
			&i.MainArea,
			&i.Area,
			&i.Section_2,
			&i.Link,
			&i.Commit,
			&i.CreatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSection = `-- name: GetSection :many
SELECT section.name
FROM section
LEFT JOIN city ON (section.city_id = city.id)
WHERE city.name = $1
`

func (q *Queries) GetSection(ctx context.Context, cityName string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getSection, cityName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
